#include "Doom.h"#include "timerutils.h"#define CURSORX 50		/* X coord of skull cursor */#define AREAY 66#define DIFFICULTYY 116#define OPTIONSY 166#define LOAD_GAME 20//#define SOUNDTIME (TICKSPERSEC/30)		/* Tics to delay the loading sequence letters */typedef enum {	level,	difficulty,	options,	load_game,	NUMMENUITEMS} menu_t;enum {		/* Enum to index to the shapes */	DIFFSHAPE1,	DIFFSHAPE2,	DIFFSHAPE3,	DIFFSHAPE4,	DIFFSHAPE5,	AREASHAPE,	DIFFSHAPE};static Word cursorframe;	/* Skull animation frame */static Word cursorcount;	/* Time mark to animate the skull */static Word cursorpos;		/* Y position of the skull */static Word movecount;		/* Time mark to move the skull */static Word playermap;		/* Map requested */static Word playerskill;	/* Requested skill */static LongWord SleepMark;	/* Time from last access */static Word CursorYs[NUMMENUITEMS] = {AREAY-2,DIFFICULTYY-2,OPTIONSY-2, LOAD_GAME-2};static Word OptionActive;static Word Loading_active;static Boolean SoundDelay;static int SoundTime;static Boolean SuccessREC;static Word NumLvl;static skill_t CurrSkill;static Word NewGameMenu;//static Word DemoFile[2048];/**********************************	Init memory needed for the main game menu**********************************/void M_Start(void){	cursorcount = 0;		/* Init the animation timer */	cursorframe = 0;		/* Init the animation frame */	cursorpos = 0;			/* Topmost y position */	playerskill = StartSkill;	/* Init the skill level */	playermap = StartMap;	/* Init the starting map */	SleepMark = ReadTick();	OptionActive = FALSE;	/* Option screen off */	SoundDelay = FALSE;	SoundTime = 0;	SuccessREC = TRUE;	Title_active = TRUE;	NewGameMenu = FALSE;		FileExists();				/* Used for drawing load level info */		if (FileInPlace == TRUE) {			ReadSaveFile();	/* Load params. I need only #level and difficulty */			ReadPrefsFile();	/* Return volumes */			NumLvl = gamemap;			CurrSkill = gameskill;		}	DemoFileExists(); /* Check for DemoFile in NVRAM */				//	ReadPrefsFile(); }/**********************************	Release memory used by the main menu**********************************/void M_Stop(void){	WritePrefsFile();		/* Save the current prefs */}/**********************************	Execute every tick**********************************/Word M_Ticker(void){	Word buttons;		buttons = JoyPadButtons;	/* Get the joypad buttons *//* Exit menu if button press */	if (TotalGameTicks > (TICKSPERSEC/2) &&		/* Minimum time... *///		((buttons & PadStart) || 		/* Start always works! */		((buttons & (PadA|PadB|PadC|PadStart)) && (cursorpos!=options) && (cursorpos!=load_game))) {		S_StartSound(0,sfx_itemup);		StartMap = playermap;	/* set map number */		StartSkill = (skill_t)playerskill;	/* Set skill level */		SleepMSec(0,150);		return ga_completed;		/* done with menu */	}		 		if (buttons) {			/* If buttons are held down then reset the timer */		SleepMark = ReadTick();	}		if (OptionActive) {		O_Control(0);		if (NewJoyPadButtons&PadX) {			Loading_active = FALSE;			OptionActive = FALSE;			NewGameMenu = FALSE;		}		return ga_nothing;	}		if (NewGameMenu) {		N_Control(0);		if (NewJoyPadButtons&PadX) {			Loading_active = FALSE;			OptionActive = FALSE;			NewGameMenu = FALSE;//			gameaction = ga_NewGStart;			}//		return gameaction;	}	if (/* (NewJoyPadButtons&PadX) ||		 Pressed abort? */		((ReadTick()-SleepMark)>=(TICKSPERSEC*15))) {		return ga_died;					/* Exit now */	}#if 0	if (Loading_active) { 		Loading_active = FALSE;		return ga_loading;	}#endif	#if 0	if (PlayingDemo) {		PlayingDemo = FALSE;		return ga_playingdemo;	}	#endif/* Animate skull */	cursorcount += ElapsedTime;		/* Add time */	if (cursorcount>=(TICKSPERSEC/4)) {	/* Time to toggle the shape? */		cursorframe ^= 1;		cursorcount = 0;		/* Reset the count */	}/* Do loading game delay for completing sound */if (SoundDelay == TRUE) {	SoundTime += ElapsedTime;		if (SoundTime >=(TICKSPERSEC/6)) {			SoundDelay = FALSE;			return ga_loading;		}}Skip:/* Check for movement */	if (! (buttons & (PadUp|PadDown|PadLeft|PadRight|PadA|PadB|PadC|PadD) ) ) {		movecount = TICKSPERSEC;	/* Move immediately on next press */	} else {		movecount += ElapsedTime;	/* Time unit */		if ( (movecount >= (TICKSPERSEC/3)) ||		/* Allow slow */			(cursorpos == level && movecount >= (TICKSPERSEC/5))) {	/* Fast? */			movecount = 0;		/* Reset the timer */						if (SoundDelay == TRUE) {				goto Skip;			}						if (buttons & PadDown) {				S_StartSound(0,sfx_itemup);				SuccessREC = TRUE;				++cursorpos;				if (cursorpos>=NUMMENUITEMS) {		/* Off the bottom? */					cursorpos = 0;				}			}			if (buttons & PadUp) {		/* Going up? */				if (!cursorpos) {		/* At the top already? */					cursorpos = NUMMENUITEMS;				}				S_StartSound(0,sfx_itemup);				SuccessREC = TRUE;				--cursorpos;			}			switch (cursorpos) {			case level:				/* Select level to start with */				if (buttons & PadRight) {					if (playermap < MaxLevel) {						++playermap;						S_StartSound(0,sfx_itemup);					}				}				if (buttons & PadLeft) {					if (playermap!=1) {						--playermap;						S_StartSound(0,sfx_itemup);					}				}				break;			case difficulty:		/* Select game difficulty */				if (buttons & PadRight) {					if (playerskill < sk_nightmare) {						++playerskill;						S_StartSound(0,sfx_itemup);					}				}				if (buttons & PadLeft) {					if (playerskill) {						--playerskill;						S_StartSound(0,sfx_itemup);					}				}				break;			case options:				if (buttons & (PadA|PadB|PadC|PadD)) {					S_StartSound(0, sfx_itemup);					OptionActive = TRUE;				} else				if (buttons & PadRight) {					S_StartSound(0, sfx_itemup);					NewGameMenu = TRUE;				}										case load_game:				//				FileExists();//					if (FileInPlace == TRUE) {//						ReadSaveFile();//					}							if ((buttons & (PadA)) && (cursorpos == load_game)) {//					FileExists();						if (FileInPlace == TRUE) {							S_StartSound(0,sfx_itemup);							SoundDelay = TRUE;	                  	   	Loading_active = TRUE; 						}							else {								if (cursorpos == load_game) {										S_StartSound(0,sfx_punch);									}								}				}				if ((buttons & (PadC)) && (cursorpos == load_game)) {//					S_StartSound(0,sfx_itemup);					/*Loading_active = TRUE;*/					//S_StopSong();										gamemap = playermap;					gameskill = (skill_t)playerskill;									if (SaveAFile((Byte *)"/NVRAM/DoomDemo",(Word *)AllocAPointer(0x8000),sizeof(2048))) {								S_StartSound(0,sfx_punch);//								SleepMSec(0,500);								SuccessREC = FALSE;								}							else	{								S_StartSound(0,sfx_itemup);								S_StopSong(); 								G_RecordDemo();			/* Record a DEMO*/								}				}									if ((buttons & (PadB)) && (cursorpos == load_game)) {//					S_StartSound(0,sfx_itemup);						if (DemoFileInPlace == TRUE) {							S_StartSound(0,sfx_itemup);							S_StopSong();							RunDemoFile();							} else					S_StartSound(0,sfx_punch);//					S_StopSong();//					RunDemoFile();				}				}		}	}	return ga_nothing;		/* Don't quit! */}/**********************************	Draw the main menu**********************************/void M_Drawer(void){	void *Shapes;		/* Pointer to shape array */	/* Draw background */	DrawRezShape(0,0,rMAINDOOM);		if (OptionActive) {		O_Drawer();	} else 		if (NewGameMenu) {		N_Drawer();	} else 			{			Shapes = LoadAResource(rMAINMENU);	/* Load shape group *//* Draw new skull */		DrawMShape(CURSORX,CursorYs[cursorpos],GetShapeIndexPtr(LoadAResource(rSKULLS),cursorframe));		ReleaseAResource(rSKULLS);/* Draw the Load game */		PrintBigFont(CURSORX+24,LOAD_GAME,(Byte *)"Load game");		PrintSmallFont(15, 140, (Byte *)"0123456789");					/* For small font testing */		PrintSmallFont(15, 150, (Byte *)"ABCDEFGHIJKLMNOPQRSTUVWXYZ");		PrintSmallFont(15, 160, (Byte *)"abcdefghijklmnopqrstuvwxyz.!");			if (cursorpos==load_game) {				PrintBigFont(CURSORX+24,60,(Byte *)"A - load game");									if (FileInPlace == TRUE) {//						if (SuccessREC == FALSE) {//								return;//							} else						PrintBigFont(20,80,(Byte *)"Level -");						PrintNumber(116,80,NumLvl,0);						PrintBigFont(20,100,(Byte *)"Diff. -");						DrawMShape(100,100,GetShapeIndexPtr(Shapes,CurrSkill));								} else									{						PrintBigFont(CURSORX+24,80,(Byte *)"No savefile");					}								PrintBigFont(CURSORX+24,130,(Byte *)"B - play demo");//				PrintBigFont(CURSORX+24,130,(Byte *)"to play demo");				if (SuccessREC == FALSE) {				PrintBigFont(55,160,(Byte *)"Free at least 8kB");				PrintBigFont(55,180,(Byte *)"to save DemoFile");			}						else {					PrintBigFont(CURSORX+24,160,(Byte *)"C - record demo");//					PrintBigFont(CURSORX+24,180,(Byte *)"to record demo");					}								}		else {/* Draw start level information */		PrintBigFont(CURSORX+24,AREAY,(Byte *)"Level");		PrintNumber(CURSORX+40,AREAY+20,playermap,0);/* Draw difficulty information */		DrawMShape(CURSORX+24,DIFFICULTYY,GetShapeIndexPtr(Shapes,DIFFSHAPE));		DrawMShape(CURSORX+40,DIFFICULTYY+20,GetShapeIndexPtr(Shapes,playerskill));/* Draw the options screen */		PrintBigFont(CURSORX+24,OPTIONSY,(Byte *)"Options Menu");				}		/* ReleaseAResource(rMAINMENU); */		/* UpdateAndPageFlip();			 Update and exit */		/* Draw the Load game *///		PrintBigFont(CURSORX+24,LOAD_GAME,(Byte *)"Load game");		/* PrintNumber(CURSORX+40,LOAD_GAME+20,playermap,0); */				ReleaseAResource(rMAINMENU);		UpdateAndPageFlip();			}}