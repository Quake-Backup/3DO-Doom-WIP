#include "Doom.h"#include <String.h>#define CURSORX 45		/* X coord for skulls */typedef enum {		/* Menu items to select from */	level,		/* level number */	difficulty,		/* difficulty */	NUMMENUITEMS} menu_t;enum {		/* Enum to index to the shapes */	DIFFSHAPE1,	DIFFSHAPE2,	DIFFSHAPE3,	DIFFSHAPE4,	DIFFSHAPE5,	AREASHAPE,	DIFFSHAPE};static Word cursorframe;		/* Skull animation frame */static Word cursorcount;		/* Time mark to animate the skull */static Word cursorpos;			/* Y position of the skull */static Word movecount;			/* Time mark to move the skull */static Word CursorYs[NUMMENUITEMS] = {65-2,120-2};static Word playermap;static Word playerskill;static Word NewGameMenu;static Boolean SoundDelay;static int SoundTime;//static LongWord SleepMark;/**********************************	Init the new game screens**********************************/void N_Init(void){	cursorcount = 0;		/* Init skull cursor state */	cursorframe = 0;	cursorpos = 0;	playermap = StartMap;	playerskill = StartSkill;	NewGameMenu = FALSE;	SoundDelay = FALSE;	SoundTime = 0;//	SleepMark = ReadTick();}/**********************************	Button bits can be eaten by clearing them in JoyPadButtons	Called by player code.	**********************************/Word N_Control(player_t *player){	Word buttons;	buttons = JoyPadButtons;	//if (TotalGameTicks > (TICKSPERSEC/2) &&//((buttons & PadStart) || //(buttons & (PadA|PadB|PadC))))	{//	S_StartSound(0,sfx_itemup);//	StartMap = playermap;//	StartSkill = (skill_t)playerskill;//	SleepMSec(0,150);//	return ga_completed;//	}		//if (buttons) {//	SleepMark = ReadTick();//}//if (NewJoyPadButtons & PadX) {//	return;//}/* animate skull */	cursorcount += ElapsedTime;	if (cursorcount >= (TICKSPERSEC/4)) {	/* Time up? */		cursorframe ^= 1;		/* Toggle the frame */		cursorcount = 0;		/* Reset the timer */	}if (! (buttons & (PadUp|PadDown|PadLeft|PadRight))) {	movecount = TICKSPERSEC;} else {	movecount += ElapsedTime;		if ((movecount >= (TICKSPERSEC/3)) ||			(cursorpos < movecount >= (TICKSPERSEC/5))) {				movecount = 0;				if (buttons & PadDown) {					S_StartSound(0,sfx_itemup);					++cursorpos;					if (cursorpos >= NUMMENUITEMS) {						cursorpos = 0;						}										}				if (buttons & PadUp) {					if (!cursorpos) {						cursorpos = NUMMENUITEMS;						}					S_StartSound(0,sfx_itemup);					--cursorpos;					}							switch (cursorpos) {					case level:						if (buttons & (PadA|PadB|PadC|PadStart)) {						S_StartSound(0,sfx_itemup);						StartMap = playermap;	/* set map number */						StartSkill = (skill_t)playerskill;	/* Set skill level */						//SleepMSec(0,150);						return ga_NewGStart;		/* done with menu */						}																if (buttons & PadRight) {							if (playermap < MaxLevel) {								++playermap;								S_StartSound(0,sfx_punch);								}							}						if (buttons & PadLeft) {							if (playermap!=1) {								--playermap;								S_StartSound(0,sfx_punch);								}							}						break;					case difficulty:						if (buttons & PadRight) {							if (playerskill < sk_nightmare) {								++playerskill;								S_StartSound(0,sfx_punch);									}								}							if (buttons & PadLeft) {								if (playerskill) {									--playerskill;									S_StartSound(0,sfx_punch);								}							}						break;											}												}		}return ga_nothing;}/**********************************	Draw new game screen**********************************/void N_Drawer(void){	void *Shapes;		/* Pointer to shape array */		Shapes = LoadAResource(rMAINMENU);	/* Load shape group *//* Draw new skull */		DrawMShape(CURSORX,CursorYs[cursorpos],GetShapeIndexPtr(LoadAResource(rSKULLS),cursorframe));		ReleaseAResource(rSKULLS);/* Draw the Load game *///		PrintBigFont(CURSORX+24,20,(Byte *)"Create new game");			/* Draw start level information */		PrintBigFont(CURSORX+24,66,(Byte *)"Level");		PrintNumber(CURSORX+40,66+20,playermap,0);/* Draw difficulty information */		DrawMShape(CURSORX+24,116,GetShapeIndexPtr(Shapes,DIFFSHAPE));		DrawMShape(CURSORX+40,116+20,GetShapeIndexPtr(Shapes,playerskill));/* Draw the options screen *///		PrintBigFont(CURSORX+24,166,(Byte *)"Options Menu");				/* Draw the Load game */			ReleaseAResource(rMAINMENU);		UpdateAndPageFlip();		}